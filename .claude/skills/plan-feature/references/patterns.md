# Patterns to Follow

## When to use this reference

Read this file when writing Tech Elab sections in user stories or when implementing stories. These are the canonical code patterns used across the project.

## Domain Entity Pattern

- `public` structs in `*Domain` / `*Application` layers need `///` doc comments on the type and every public property (see `docs/SWIFT.md`)
- All properties are `let`, `Identifiable`, `Equatable`, `Sendable`

```swift
/// A movie.
public struct Movie: Identifiable, Equatable, Sendable {
    /// Movie identifier.
    public let id: Int
    /// Movie name.
    public let name: String

    public init(id: Int, name: String) {
        self.id = id
        self.name = name
    }
}
```

## Mapper Pattern

Three layers of mappers, each with distinct responsibilities:

### Adapter Mapper (TMDb → Domain)

Maps TMDb SDK types to domain entities. No business logic.

```swift
struct {Name}Mapper {
    func map(_ dto: TMDb.X) -> Domain.X {
        Domain.X(
            id: dto.id,
            name: dto.name
        )
    }
}
```

### Application Mapper (Domain → Application)

Resolves images and enriches domain entities with configuration data.

```swift
struct {Name}Mapper {
    func map(_ entity: Domain.X, imagesConfiguration: ImagesConfiguration) -> App.X {
        App.X(
            id: entity.id,
            name: entity.name,
            posterURLSet: imagesConfiguration.posterURLSet(for: entity.posterPath)
        )
    }
}
```

### Feature Mapper (Application → Feature)

Picks specific URL sizes and shapes data for the view.

```swift
struct {Name}Mapper {
    func map(_ appModel: App.X) -> Feature.X {
        Feature.X(
            id: appModel.id,
            name: appModel.name,
            posterURL: appModel.posterURLSet?.card
        )
    }
}
```

## Repository Pattern

Cache-first with remote fallback. Observability spans on all operations.

```swift
final class Default{Entity}Repository: {Entity}Repository, Sendable {
    private let remoteDataSource: any {Entity}RemoteDataSource
    private let localDataSource: any {Entity}LocalDataSource

    func {entity}(withID id: Int) async throws({Entity}RepositoryError) -> {Entity} {
        if let cached = try? await localDataSource.{entity}(withID: id) {
            return cached
        }
        do {
            let result = try await remoteDataSource.{entity}(withID: id)
            try? await localDataSource.save(result, withID: id)
            return result
        } catch let error as {Entity}RemoteDataSourceError {
            throw error.repositoryError
        }
    }
}
```

## SwiftData Entity Pattern

`@Model` classes with `@ModelActor` data sources. See `docs/SWIFTDATA.md`.

```swift
@Model
final class {Entity}Entity {
    @Attribute(.unique) var entityID: Int
    var name: String
    var cachedAt: Date

    init(entityID: Int, name: String, cachedAt: Date = .now) {
        self.entityID = entityID
        self.name = name
        self.cachedAt = cachedAt
    }
}
```

### Entity Mapper (3-method pattern)

```swift
struct {Entity}EntityMapper {
    func map(_ entity: {Entity}Entity) -> {Entity} { ... }
    func map(_ domain: {Entity}) -> {Entity}Entity { ... }
    func update(_ entity: {Entity}Entity, from domain: {Entity}) { ... }
}
```

## Localisation Pattern

- Every new `.xcstrings` key needs `"isCommentAutoGenerated" : true` alongside its comment
- Format-string keys (e.g. `"Value %lld"`) need an explicit `localizations` section with English translation — they won't get one automatically from Xcode
- Use `bundle: .module` for localised strings in packages

## Test Pattern

- Swift Testing framework (`@Suite`, `@Test`, `#expect`, `#require`)
- Mock factories: `static func mock(...defaults...) -> Entity`
- Feature tests: `TestStore` with `withDependencies`
- SwiftLint limits: `function_body_length` 50, `file_length` 400, `type_body_length` 350
- `@Model` classes aren't `Sendable` — use `static func makeEntity()` factory methods, NOT `static let`

### Required Test Coverage Per Layer

Every new feature MUST have tests at ALL of these layers. Missing any layer is a review blocker.

#### Adapter Mapper Tests

Every adapter mapper (TMDb → Domain) needs its own test file. Test all properties, nil/optional handling, and empty collections.

```swift
@Suite("{Name}Mapper Tests")
struct {Name}MapperTests {
    private let mapper = {Name}Mapper()

    @Test("map converts all properties correctly")
    func mapConvertsAllPropertiesCorrectly() { ... }

    @Test("map handles nil optional properties")
    func mapHandlesNilOptionalProperties() { ... }

    @Test("map handles empty collections")
    func mapHandlesEmptyCollections() { ... }
}
```

#### Use Case Tests

Every use case needs tests for: success, ID propagation, each error type (notFound, unauthorised, unknown), and upstream failures.

```swift
@Suite("DefaultFetch{Entity}UseCase Tests")
struct DefaultFetch{Entity}UseCaseTests {
    @Test("returns entity on success")
    func returnsEntityOnSuccess() async throws { ... }

    @Test("propagates correct ID to repository")
    func propagatesCorrectIDToRepository() async throws { ... }

    @Test("throws not found error")
    func throwsNotFoundError() async throws { ... }

    @Test("throws unauthorised error")
    func throwsUnauthorisedError() async throws { ... }

    @Test("throws unknown error")
    func throwsUnknownError() async throws { ... }
}
```

#### TCA Reducer Tests

Every reducer needs `@MainActor` and `State: Equatable` (required for `TestStore`). Cover: initial state, fetch success → ready, fetch failure → error, guard states, and navigation actions.

```swift
@MainActor
@Suite("{Feature}Feature Tests")
struct {Feature}FeatureTests {
    // State MUST conform to Equatable for TestStore
    // Use explicit types when @ObservableState obscures inference:
    //   Feature.Action.loaded(snapshot)  instead of  .loaded(snapshot)
    //   ViewState<Feature.ViewSnapshot>.error(...)  instead of  .error(...)

    @Test("fetch success transitions to ready")
    func fetchSuccessTransitionsToReady() async { ... }

    @Test("fetch failure transitions to error")
    func fetchFailureTransitionsToError() async { ... }

    @Test("fetch does nothing when already ready")
    func fetchDoesNothingWhenAlreadyReady() async { ... }

    @Test("fetch does nothing when already loading")
    func fetchDoesNothingWhenAlreadyLoading() async { ... }
}
```

## View Pattern

- Content views separate from store-connected views
- Callbacks for navigation (not store references)
- `#Preview` blocks with mock data
- Accessibility identifiers and labels
- In coordinator views (`ExploreRootView`, `SearchRootView`), each destination must be a `private func` helper — never inline in `switch` cases. Both coordinators must be updated consistently (see `docs/SWIFTUI.md`)

## Test Plan Registration

When adding new unit test targets, register them in `TestPlans/PopcornUnitTests.xctestplan` by adding an entry to the `testTargets` array. Without this, the tests won't run when executing the test plan. Do NOT add snapshot test targets here — those belong in `PopcornSnapshotTests.xctestplan`.

```json
{
  "target" : {
    "containerPath" : "container:{relative/path/to/package}",
    "identifier" : "{TestTargetName}",
    "name" : "{TestTargetName}"
  }
}
```

## Feature Flag Creation Pattern

When a story adds a new feature flag, two things must happen:

### 1. Code — Add to `FeatureFlag.swift`

Add a `static let` property and register it in `allFlags`. Update `FeatureFlagTests.swift` (count + ID list).

### 2. Statsig — Create the Gate via MCP

Create the corresponding Statsig gate using the Statsig MCP. Enable it for the **development environment only** (not a full public rollout):

```
1. mcp__statsig__Get_Gate_Details_by_ID — read a sibling gate to match config pattern
2. mcp__statsig__Create_Gate — create with:
   - id: matching FeatureFlag.id (snake_case)
   - name: Title Case version of the ID
   - rule: "Development only", passPercentage 100, condition type "public",
     environments: ["development"]
3. mcp__statsig__Update_Gate_Entirely — add description:
   "Controls access to <feature name>"
```

The gate ID in Statsig **must** match the `FeatureFlag.id` in code.

## Factory Chain Pattern

When adding a new data source or use case, the factory init chain must be updated atomically:

```
{Context}AdaptersFactory  (accepts new service/data source)
  → Live{Context}Factory  (accepts new remote data source)
    → {Context}InfrastructureFactory  (creates repository)
      → {Context}ApplicationFactory  (creates use case)
        → {Context}ApplicationFactory+TCA.swift  (wires dependencies)
```

All 5 files must compile together — update them in the same story or ensure strict dependency ordering.
