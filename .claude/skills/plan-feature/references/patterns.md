# Patterns to Follow

## When to use this reference

Read this file when writing Tech Elab sections in user stories or when implementing stories. These are the canonical code patterns used across the project.

## Domain Entity Pattern

- `public` structs in `*Domain` / `*Application` layers need `///` doc comments on the type and every public property (see `docs/SWIFT.md`)
- All properties are `let`, `Identifiable`, `Equatable`, `Sendable`

```swift
/// A movie.
public struct Movie: Identifiable, Equatable, Sendable {
    /// Movie identifier.
    public let id: Int
    /// Movie name.
    public let name: String

    public init(id: Int, name: String) {
        self.id = id
        self.name = name
    }
}
```

## Mapper Pattern

Three layers of mappers, each with distinct responsibilities:

### Adapter Mapper (TMDb → Domain)

Maps TMDb SDK types to domain entities. No business logic.

```swift
struct {Name}Mapper {
    func map(_ dto: TMDb.X) -> Domain.X {
        Domain.X(
            id: dto.id,
            name: dto.name
        )
    }
}
```

### Application Mapper (Domain → Application)

Resolves images and enriches domain entities with configuration data.

```swift
struct {Name}Mapper {
    func map(_ entity: Domain.X, imagesConfiguration: ImagesConfiguration) -> App.X {
        App.X(
            id: entity.id,
            name: entity.name,
            posterURLSet: imagesConfiguration.posterURLSet(for: entity.posterPath)
        )
    }
}
```

### Feature Mapper (Application → Feature)

Picks specific URL sizes and shapes data for the view.

```swift
struct {Name}Mapper {
    func map(_ appModel: App.X) -> Feature.X {
        Feature.X(
            id: appModel.id,
            name: appModel.name,
            posterURL: appModel.posterURLSet?.card
        )
    }
}
```

## Repository Pattern

Cache-first with remote fallback. Observability spans on all operations.

```swift
final class Default{Entity}Repository: {Entity}Repository, Sendable {
    private let remoteDataSource: any {Entity}RemoteDataSource
    private let localDataSource: any {Entity}LocalDataSource

    func {entity}(withID id: Int) async throws({Entity}RepositoryError) -> {Entity} {
        if let cached = try? await localDataSource.{entity}(withID: id) {
            return cached
        }
        do {
            let result = try await remoteDataSource.{entity}(withID: id)
            try? await localDataSource.save(result, withID: id)
            return result
        } catch let error as {Entity}RemoteDataSourceError {
            throw error.repositoryError
        }
    }
}
```

## SwiftData Entity Pattern

`@Model` classes with `@ModelActor` data sources. See `docs/SWIFTDATA.md`.

```swift
@Model
final class {Entity}Entity {
    @Attribute(.unique) var entityID: Int
    var name: String
    var cachedAt: Date

    init(entityID: Int, name: String, cachedAt: Date = .now) {
        self.entityID = entityID
        self.name = name
        self.cachedAt = cachedAt
    }
}
```

### Entity Mapper (3-method pattern)

```swift
struct {Entity}EntityMapper {
    func map(_ entity: {Entity}Entity) -> {Entity} { ... }
    func map(_ domain: {Entity}) -> {Entity}Entity { ... }
    func update(_ entity: {Entity}Entity, from domain: {Entity}) { ... }
}
```

## Localisation Pattern

- Every new `.xcstrings` key needs `"isCommentAutoGenerated" : true` alongside its comment
- Format-string keys (e.g. `"Value %lld"`) need an explicit `localizations` section with English translation — they won't get one automatically from Xcode
- Use `bundle: .module` for localised strings in packages

## Test Pattern

- Swift Testing framework (`@Suite`, `@Test`, `#expect`, `#require`)
- Mock factories: `static func mock(...defaults...) -> Entity`
- Feature tests: `TestStore` with `withDependencies`
- SwiftLint limits: `function_body_length` 50, `file_length` 400, `type_body_length` 350
- `@Model` classes aren't `Sendable` — use `static func makeEntity()` factory methods, NOT `static let`

## View Pattern

- Content views separate from store-connected views
- Callbacks for navigation (not store references)
- `#Preview` blocks with mock data
- Accessibility identifiers and labels
- In coordinator views (`ExploreRootView`, `SearchRootView`), each destination must be a `private func` helper — never inline in `switch` cases. Both coordinators must be updated consistently (see `docs/SWIFTUI.md`)

## Test Plan Registration

When adding new unit test targets, register them in `TestPlans/PopcornUnitTests.xctestplan` by adding an entry to the `testTargets` array. Without this, the tests won't run when executing the test plan. Do NOT add snapshot test targets here — those belong in `PopcornSnapshotTests.xctestplan`.

```json
{
  "target" : {
    "containerPath" : "container:{relative/path/to/package}",
    "identifier" : "{TestTargetName}",
    "name" : "{TestTargetName}"
  }
}
```

## Factory Chain Pattern

When adding a new data source or use case, the factory init chain must be updated atomically:

```
{Context}AdaptersFactory  (accepts new service/data source)
  → Live{Context}Factory  (accepts new remote data source)
    → {Context}InfrastructureFactory  (creates repository)
      → {Context}ApplicationFactory  (creates use case)
        → {Context}ApplicationFactory+TCA.swift  (wires dependencies)
```

All 5 files must compile together — update them in the same story or ensure strict dependency ordering.
